##' @title Sager Data
##'
##' @description
##'
##' A set of function to install and access sage data. Three datasets
##' are available: a TMT11 quantitation tsv file, a identification tsv
##' file, both generated by *sage*, and an mzML file that contains the
##' raw data used as input to *sage*.
##'
##' The data were downloaded from the ProteomeXchange project
##' PXD016766 (see reference below) and processed with sage version
##' 0.10.0 and subset to reduce their size. See
##' `inst/scripts/make-data.R` for details on how these data were
##' generated and subset.
##'
##'
##' @section Functions:
##'
##' - `sagerMzMLData()` returns the path to the cached mzML file.
##'
##' - `sagerQuantData()` returns the path to the cached quantitation
##'    tab-separated file.
##'
##' - `sagerIdData()` returns the path to the cached identifcation
##'    tab-separated file.
##'
##' - `sagerAddData(which, cache)` checks if the resources are already
##'    available in the cache (default is `sagerCache()`). If not,
##'    data are downloaded and added to the cache.
##'
##' - `sagerRemoveData(which, cache)` removes the cached resource.
##'
##' The `sagerMzMLData()`, `sagerQuantData()` and `sagerIdData()` use
##' the `sager::sagerData()` function under the hood, that defined the
##' resource name and the cache.
##'
##' The data files are available on zenodo (10.5281/zenodo.7804639)
##' and are downloaded and cached by the `sagerAddData()` function to
##' become accessible.
##'
##' @param cache Object of class `BiocFileCache`. Default for is the
##'     package's cache returned by `sagerCache()`.
##'
##' @param rname `character(1)` defining the resource name used to
##'     query `cache`.
##'
##' @importFrom BiocFileCache bfcquery BiocFileCache
##'
##' @importFrom utils packageDescription
##'
##' @export
##'
##' @rdname sagerData
##'
##' @references
##'
##' - Project PXD016766:
##' [www.ebi.ac.uk/pride/archive/projects/PXD016766](https://www.ebi.ac.uk/pride/archive/projects/PXD016766).
##'
##' - Yu *et al.* 'Benchmarking the Orbitrap Tribrid Eclipse for Next
##'   Generation Multiplexed Proteomics' Anal. Chem. 2020, 92, 9,
##'   6478â€“6485 Publication Date:April 6, 2020
##'   [DOI:10.1021/acs.analchem.9b05685](https://doi.org/10.1021/acs.analchem.9b05685).
##'
##' - sager package test data: [DOI: 10.5281/zenodo.7804639](https://doi.org/10.5281/zenodo.7804639).
##'
##' @examples
##'
##' sagerQuantData()
##'
##' sagerIdData()
##'
##' sagerMzMLData()
sagerData <- function(cache, rname) {
    if (missing(rname))
        stop("Please provide a resource name to query the cache.")
    if (missing(cache))
        stop("Please provide BiocFile cache.")
    x <- bfcquery(cache, rname, field = "rname")
    if (!nrow(x)) {
        warning("Data not found. See ?sagerData for details.")
        return(NA)
    }
    if (nrow(x) > 1)
        stop("Found > 1 resource found. Please open an issue in",
             packageDescription("sager")$BugReports,
             "with the exact code you ran and your session information.")
    x$rpath
}



##' @export
##'
##' @rdname sagerData
##'
##' @importFrom tools R_user_dir
##'
##' @importFrom BiocFileCache BiocFileCache
sagerCache <- function() {
    cache <- tools::R_user_dir(package = "sager", which = "cache")
    BiocFileCache::BiocFileCache(cache, ask = interactive())
}

##' @title Sager Cache Resource Identifiers
##'
##' @description
##'
##' This function is used internally to keep track of the resource
##' names (rname) in the package's cache in functions such as
##' `sagerQuantData()`, ... that return the path to a resource
##' (rpath). When new data are added to the cache, their rname should
##' be added here.
##'
##' @param which `character()` specifying what type of resource to
##'     return.
##'
sager_rids <- function(which = c("quant", "id", "mzml")) {
    rids <- c(quant = "sager_subset_quant",
              id = "sager_subset_id",
              mzml = "sager_subset_PXD016766")
    which <- match.arg(which, several.ok = TRUE)
    rids[which]
}

##' @export
##'
##' @rdname sagerData
sagerQuantData <- function()
    sagerData(cache = sagerCache(),
              rname = sager_rids("quant"))

##' @export
##'
##' @rdname sagerData
sagerIdData <- function()
    sagerData(cache = sagerCache(),
              rname = sager_rids("id"))

##' @export
##'
##' @rdname sagerData
sagerMzMLData <- function()
    sagerData(cache = sagerCache(),
              rname = sager_rids("mzml"))

##' @export
##'
##' @rdname sagerData
##'
##' @param which One or several of `"quant"`, `"id"` or `"mzml"`
##'     specifying what data to download.
sagerAddData <- function(which = c("quant", "id", "mzml"),
                         cache = sagerCache()) {
    which <- match.arg(which, several.ok = TRUE)
    urls <- c(id = "https://zenodo.org/record/7804639/files/1e70515047b45_subset_results.sage.tsv",
              mzml = "https://zenodo.org/record/7804639/files/1e7051d5dbf58_sager_subset_PXD016766.mzML?download=1",
              quant = "https://zenodo.org/record/7804639/files/1e705d5d7e79_subset_quant.tsv?download=1")
    for (i in which) {
        r_i <- bfcquery(cache, sager_rids(i), field = "rname", exact = TRUE)
        ## Check if the resource is already available
        if (nrow(r_i) == 1)
            message("'", i, "'", " already available.")
        ## Error if multiple matches
        else if (nrow(r_i) > 1)
            stop("Found > 1 resource found. Please open an issue in",
                 packageDescription("sager")$BugReports,
                 "with the exact code you ran and your session information.")
        else { ## Add the resource
            message("Adding '", i, "' to the package cache.")
            bfcadd(cache, rname = sager_rids(i), urls[i])
        }
    }
    invisible(cache)
}

##' @export
##'
##' @rdname sagerData
##'
##' @importFrom BiocFileCache bfcremove bfcquery
sagerRemoveData <- function(which = c("quant", "id", "mzml"),
                            cache = sagerCache()) {
    which <- match.arg(which, several.ok = TRUE)
    rids <- sager_rids(which)
    x <- bfcquery(cache, rids, field = "rname", exact = TRUE)
    if (!nrow(x)) {
        message("Resource(s) not found, none removed.")
        return(invisible(cache))
    }
    bfcremove(cache, x$rid)
}
