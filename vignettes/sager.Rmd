---
title: "Using the `sager` package to import and analyse `sage` results in R"
author:
  - name: Laurent Gatto
    affiliation:
    - Computational Biology and Bioinformatics, UCLouvain
    email: laurent.gatto@uclouvain.be
output:
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
package: "`r pkg_ver('sager')`"
vignette: >
  %\VignetteIndexEntry{The sager package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    crop = NULL ## Related to https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
    )
suppressPackageStartupMessages(library("BiocStyle"))
```


# Introduction

## The `sager` package

[Sage](https://lazear.github.io/sage/) is a new cross-platform,
extremely performant, open source proteomics search engine [Michael
Lazear](https://github.com/lazear). It uses mzML files as input, is
parameterised by a [json
file](https://github.com/lazear/sage/blob/master/DOCS.md) and is
executed from the command line. In addition to peptide identification,
sage also includes a variety of advanced features such as retention
time prediction and quantification (both isobaric & LFQ). It produces
two files: `results.sage.tsv` with the identification results and,
when configured to quantify features, `quant.tsv`.

The `sager` package uses these two files as input. It facilitates
their import into established Bioconductor classes:

- Identification results are parsed and imported as
  [PSMatch::PSM()](https://rformassspectrometry.github.io/PSMatch/)
  objects with `sagePSM()`.

- Quantitation (and identification) results are parsed, merged and
  imported as
  [QFeatures::QFeatures()](https://rformassspectrometry.github.io/QFeatures/articles/QFeatures.html)
  objects with `sageQFeatures()`.

- Sage results can also be integrated with a
  [Spectra::Spectra()](https://rformassspectrometry.github.io/Spectra/)
  instance (holding the raw data) into a
  [MsExperiment::MsExperiment()](https://rformassspectrometry.github.io/MsExperiment/)
  object, as documented in this document.

The goal of the `sager` package can thus be summarised as a way to
leverage the existing [R for Mass
Spectrometry](https://www.rformassspectrometry.org/) and
[Bioconductor](https://bioconductor.org/) infrastructure to analyse
sage results.

## Installation instructions

To install `sager` and its dependencies, you'll need the `BiocManager`
package, that can be installed from CRAN (unless you already have it):

```{r installbiocmanager, eval = FALSE}
if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")
```

Note that `sager` is under constant development, and thus will depend
on some under-development dependencies, that haven't made it into the
stable releases yet. Here are the instructions to install these:

To install the *devel* version of `PSMatch`:

```{r installpsmatch, eval = FALSE}
BiocManager::install("RforMassSpectrometry/PSMatch")
```

To install `sager` and its dependencies, you can run the following
command:

```{r installsager, eval = FALSE}
BiocManager::install("UCLouvain-CBIO/sager")
```


# Analysing `sage` results

## Example data

```{r loadpkg}
library(sager)
```

The `sager` package provides example data

```{r dataavailability}
sagerAvailableData()
```

```{r dataadd}
sagerAddData()
```

For details and provenance of the data, please see the `?sagerData`
manual page.

## Identification data

```{r sagePSM, message = FALSE}
library(PSMatch)
psm <- sagePSM(sagerIdData())
psm
```

```{r ggplot, message = FALSE}
library(ggplot2)
data.frame(psm) |>
    ggplot(aes(x = hyperscore,
               colour = label)) +
    geom_density()
```

```{r ggplog2}
data.frame(psm) |>
    ggplot(aes(x = spectrum_fdr,
               colour = label)) +
    geom_density()
```

```{r filterPSM}
psm <- filterPSMs(psm) |>
    filterPsmFdr()
```

## Quantitative data

```{r, message = FALSE}
library(QFeatures)
library(scp)
```

Multiple fractions for the same set of samples:

```{r qf1}
qf1 <- sageQFeatures(sagerQuantData(), sagerIdData(), splitBy = NULL)
qf1
```

```{r qf1process}
qf1 |>
    filterFeatures(~ label > 0) |>
    filterFeatures(~ rank == 1) |>
    filterFeatures(~ spectrum_fdr < 0.05) |>
    zeroIsNA(1) |>
    logTransform(i = 1, name = "log_sage") |>
    normalize(i = "log_sage",
              name = "norm_sage",
              method = "center.mean") |>
    aggregateFeatures(i = "norm_sage",
                      name = "proteins",
                      fcol = "proteins",
                      fun = colMedians,
                      na.rm = TRUE) -> qf1
```

```{r}
plot(qf1)
```

```{r}
qf1
```


Different sets of samples per acquisition:

```{r qf2}
qf <- sageQFeatures(sagerQuantData(), sagerIdData())
qf
```

Annotate data:

```{r}
renameqf <- function(x) sub("\\.mzML", "", sub("^.+hrMS2_", "", x))
qf$filename <- rep(names(qf), each = 11)
qf$tmt_tag <- rep(paste0("tmt_", 1:11), length(qf))
qf$acquisition <- renameqf(qf$filename)
names(qf) <- paste0("psm", renameqf(names(qf)))
qf <- renamePrimary(qf, paste(qf$acquisition, qf$tmt_tag, sep = "."))
colnames(qf) <- CharacterList(lapply(colnames(qf), renameqf))
```

```{r}
qf
colData(qf)
```

Data processing:

```{r}
qf |>
    filterFeatures(~ label > 0) |>
    filterFeatures(~ rank == 1) |>
    filterFeatures(~ spectrum_fdr < 0.05) |>
    zeroIsNA(1:3) |>
    logTransform(i = 1:3, name = paste0("log_", names(qf))) |>
    aggregateFeaturesOverAssays(i = 4:6,
                                fcol = "peptide",
                                name = sub("psm", "peptide", names(qf)),
                                fun = colMedians,
                                na.rm = TRUE) |>
    joinAssays(i = 7:9,
               name = "peptides") |>
    normalize(i = 10,
              name = "norm_peptides",
              method = "center.mean") |>
    aggregateFeatures(i = "norm_peptides",
                      name = "proteins",
                      fcol = "proteins",
                      fun = colMedians,
                      na.rm = TRUE) -> qf
```


```{r}
plot(qf)
```

```{r}
qf
```

## Spectra and Quantitative data

We have seen above how to import and process identification and
quantitation data produced by sage using standard R/Bioconductor
tools. Our main goal is to integrate these with the raw MS data that
was used to generate them.

Let's start by importing these raw data into R as a `Spectra`
object. The three mzML files can be retrieved with the
`sagerMzMLData()` function.

```{r spectra, message = FALSE}
library(Spectra)
sp <- Spectra(sagerMzMLData())
sp
```

We can now create a *key* to identify features (spectra, in this case)
within the `sp` object. Later, we will create a similar key in the
`QFeatures` and `PSM` objects generated above. The goal of these keys
will be to identify matching features across data types, such as for
example to match de MS spectra to the PSMs and peptides or
proteins. These different data types can be stored together in an
`MsExperiment` object, and matched through one or multiple keys.

We can add a key (by default, names `.KEY` that will identify a
feature/scan by concatenating the scan number and the file in which
that scan was acquired.

```{r addkeySpectra}
sp$filename <- basename(dataOrigin(sp))
sp <- addKEY(sp, vars = c("filename", "spectrumId"))
head(sp$.KEY)
```

Let's do the same of the PSM object created above:

```{r addkeyPSM}
psm <- addKEY(psm, vars = c("filename", "scannr"))
head(psm$.KEY)
```

And finally, with the QFeatures object.

```{r addkeyQFeatures}
qf <- addKEY(qf, vars = c("file", "scannr"))
```

Running `addKEY` on a `QFeatures` object will only add a key to assays
that do have the relevant variables:

```{r}
sapply(rowData(qf), function(x) ".KEY" %in% names(x))
head(rowData(qf[["psmA5"]])$.KEY)
```

Let's now bundle these three types of data together into and
`MsExperiment` object:

```{r mse}
library(MsExperiment)
mse <- MsExperiment()
spectra(mse) <- sp
qdata(mse) <- qf
mse@otherData$PSM <- psm
```

```{r}
mse
```

Each data element `mse` is references by the same key, which we can
now use on the the `MsExperiment` object, that will percolate the
request to its components.


# Misc

## Getting help

Please [open an issue](https://github.com/UCLouvain-CBIO/sager/issues)
on the package's Github repository.

<!-- ## Citing `sager` -->

<!-- ```{r citation} -->
<!-- citation("sager") -->
<!-- ``` -->

## Session information

```{r si, echo = FALSE}
sessionInfo()
```
